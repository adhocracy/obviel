Rendering of content on another element
=======================================

Problem description
-------------------

This discusses both a problem with form rendering and one or more possible
solutions, nothing has yet been implemented...

In most cases, if a form gets submitted, the server sends back data to fill the
space formerly occupied by the form, either new form data (when there were form
errors or just because we are displaying an edit page) or just the data of the
object that we've added or edited. However, it is also quite common to get back
data for a parent, or grandparent element, or even for a completely unrelated
element. The form may for instance have been used to add an element to a tree
which we want to refresh, the form save has changed tab data in a set of tabs,
which needs to be refreshed, or the response may contain a message, or status
information, that needs to be displayed.

Of course, this can be dealt with by retrieving the (grand-)parent using
views.viewParent() and then rendering the view on that. However, this means
that the decision on which element the view is rendered is made in the form
view that processes the server response, which would require the form view
to examine the server response and delegate rendering in certain cases,
which is rather unpleasant (and is currently not possible, right now the
response is rendered on the same element as the form view, which can not be
overridden without overriding the form submit hook).

Another option (currently used) is to define a 'parent-render' view that finds
the viewParent, but this requires direct knowledge of the element structure
of the client on the server (for instance, adding an additional view layer
would require the view to be rendered on the grandparent instead of the parent,
in which case the interface would need to be changed from 'parent-render' to
'grandparent-render' or whatnot), which is also far from pleasant. (Note
that it is clear that this is not a nice solution by looking at the iface
name, 'parent-render' is not a data description but information about how
a data structure should be rendered, while ifaces should always describe
data structures.)

In short: we want to be able to provide a structure from the server that
does not contain presentation information (where should i render this content)
and have it displayed on an element other than the 'current' one (of the form
view that triggered the submit for which the structure is a response) without
having to intervene in the form response processing (determining where data is
rendered by inspecting the data).

Use cases
---------

We have identified a small set of basic use cases, which I want to use to test
possible solutions against:

  * up our branch - parent-render, tabs

    the most common problem seems to be that of a form submit having to lead
    to a parent, or grand-parent update, for instance if a form is inside a
    set of tabs, the form submit may require the tabs to be updated, or a
    different tab to be displayed

  * outside our branch - status update/message

    in some cases, we want to render contents on a location unrelated to the
    'current' element, for instance we may want to display a message somewhere
    in a message box, or we want to reflect a status change of an object after
    an edit, somewhere else on the page

  * down our branch - children update

    it seems that there's also a use case for having contents rendered in
    a (grand-)child element, though 

Solutions
---------

A key to finding a solution to not have presentation knowledge either on the
server (where it doesn't belong), nor on the form view (where it doesn't belong
either) seems to be that a view is not bound to an element, or a set of
elements, when in some cases we want it to be. Say we have a structure with an
iface 'tabs', and the system would know that the current element (the one on
which the form view was rendered) wouldn't allow rendering of such a 'tabs'
structure, and would know about how to find the nearest element that would
allow rendering it, it could find that element and render the structure on it
without having knowledge about that behaviour on the server or in the form
view.

After some discussion, we identified 2 distinctive ways of binding a view to
one or more elements: by providing the elements, or some reference or way of
getting to them, at view registration time, or by using the event mechanism
to allow intervening in rendering a view from other views.

Providing element(s) on view registration
-----------------------------------------

We could change the views library in such a way, that on registration of a view
one or more elements, or some form of JQuery selector, could be passed, so that
if the system would find a view for a certain context (either by iface or by
name), it could detect that this special registration has occurred, and render
on the element(s) provided rather than the element of the previous (form) view.
A large advantage of using this technique would be that the mechanism is
relatively simple to implement and use.

A problem with this solution is that it's quite unclear what to provide at
registration time, a simple selector string (if so, on what element would it be
resolved?), or a complete selector (if so, what element should we provide? in
most cases the context element of a selector is not yet available, and also the
selector should be resolved at render time rather than at registration time),
or perhaps even a function (this would solve the previous issues, but is a lot
less nice for registration)? Since the latter is the only solution that seems
to provide the flexibility we aim for without having to resort to scary magical
hacks (e.g. we could re-resolve a selector provided at config time, but I don't
want to go there) I'm going to use that for our examples.

DISCUSS: is there an elegant way to not only provide the selector, but also
the context element (or something that resolves to the context element) on
view definition time? It's possible to re-resolve a selector (e.g. when
providing $('.foo', document) on view definition, this can be resolved later
by executing $(sel.selector, sel.context) later on to get elements with class
'foo' if they were generated after the view was instantiated), is something
like that a good option to make this solution a bit more elegant? Or perhaps
there's something besides JQ selector that we can register our views on, like
class name, which is than found by traversing up and down the tree much like
the event mechanism does, but in that case, how do we get outside our branch?

Using the event mechanism to intervene into the rendering process
-----------------------------------------------------------------

An entirely different way of making that selection of where a view should be
rendered involves using JQuery's event mechanism. If we would change the code
that deals with a form submit in such a way that instead of mindlessly
rendering the response on the current element, it would send out an event
with that behaviour as default, code could register sophisticated handlers
that could render that context, in whole or partial, and then decide that no
other rendering would be required by calling event.preventDefault().

Playing around a bit
--------------------

Let's try out our solutions by trying to solve our use cases (using some
incomplete JS code snippets)::

  // change registration, trying to solve the parent-render (tabs)
  // issue
  views.view({
    iface: 'tabs',
    render: function() {...},
    element: function(el, obj, name) {
      // get the nearest parent that has a certain class
      while (!el.hasClass('tabsel')) {
        el = el.parent();
      };
      return el;
    }
  });

  // override view using events mechanism, trying to solve parent-render
  views.view({
    iface: 'tabs',
    render: function(el, obj, name) {
      ...
      // register a handler on el to intervene in rendering of sub views
      el.bind('views.before-render', function(event, subel, obj, name) {
        // respond only in certain cases, ignore other view events and also
        // ignore this event if it's on our target already to avoid
        // recursion
        if (!views.implements(obj, 'tabs') || el.hasClass('tabs')) {
          return;
        };
        el.render(obj, name); // render on our own el
        event.preventDefault(); // do not try to render on subel anymore
      });
    }
  });

  // change registration, solving the message issue (element at arbitrary loc)
  views.view({
    iface: 'message',
    render: function(el, obj, name) {
      // 'el' here refers to whatever the 'element' function below provides,
      // since this function is called before anything is actually rendered,
      // the original element is left untouched and only the messageel's
      // contents is changed
      el.text(obj.message);
    },
    element: function(el, obj, name) {
      // 'el' here refers to the element on which render() is called
      return $('.messageel', document);
    }
  });

  // using event mechanism to solve the arbitrary element issue
  views.view({
    iface: 'message',
    render: function(el, obj, name) {...}
  });

  // we register a handler on document so we know for sure the event handler
  // will at some point reach it no matter where the event originated, then
  // find the right element from the handler
  $(document).bind('views.before-render', function(event, el, obj, name) {
    // note that this will be called before _any_ view is rendered, we only
    // want to intervene in the message ones
    if (!views.implements(obj, 'message') || el.hasClass('messageel')) {
      return;
    };
    $('.messageel', document).render(obj, name);
    event.preventDefault();
  });

  // solving the child element issue using the registration change
  views.view({
    iface: 'bla',
    render: function() {...},
    element: function(el, obj, name) {
      // return the child element on which rendering should happen
      return $('.bla', el);
    }
  });

  // solving the child element issue using the events mechanism
  // we have to register the handler after the child element was created, so
  // the most logical location is the 'parent' view (the form view that causes
  // the submit action)
  views.formview({
    iface: 'someform',
    render: function(el, obj, name) {
      // call super's render first
      formviews.FormView.prototype.render.call(el, obj, name);
      // now register the handler on our own element, when the event occurs
      // find the right element to render on and cancel default
      el.bind(
          'views.before-render', function(event, el, obj, name) {
        if (!views.implements(obj, 'bla') || el.hasClass('bla')) {
          return;
        };
        $('.bla', el).render(obj, name);
        event.preventDefault();
      });
    }
  });

  // and the actual view of course needs to be provided too
  views.view({
    iface: 'bla',
    render: function() {...}
  });



Pros and cons
-------------

So far, I see the following pros and cons to the proposed solutions:

  * pros for changing view registration

    - registration is relatively clear and simple, doesn't require additional
      mechanisms

    - behaviour is relatively clear, a view gets rendered on an element just
      like before, but we just switch the element, no strange pipe-lining
      or bubbling or whatnot behaviour, less room for errors

  * cons for changing view registration

    - the only way to get to the right element seems to be by using a function
      rather than a selector of some sort - this is rather ugly

    - no complex schemes where context is rendered at multiple locations

  * pros for event mechanism

    - using a relatively well-known mechanism to deal with delegation

    - allows very complex rendering of context objects on multiple locations

  * cons for event mechanism

    - binding happens outside of view registration, which makes code less
      easy to read

    - additional complexity increases the risk of errors, most notably having
      to make sure the event is only caught in certain cases is rather icky
