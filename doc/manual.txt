Obviel: Object/View/Element for jQuery
======================================

Introduction
------------

What does Obviel really *do*? Obviel lets you associate *views* with
JSON objects. You are the person who writes the views in
JavaScript. In the view definition, you write JavaScript code that can
render the information in the JSON object into the browser DOM. This
interplay of *object*, *view* and *element* is central to Obviel. It
also inspires its name, *Ob*-*vi*-*el*.

What does Obviel ask you to do?

* you must, typically on the server side, add simple type information
  to the JSON *objects* that you want to render with views on the
  client.  This is done using the *ifaces* property. We also call such
  JSON objects *model*.

* you must, on the client side, define *views* that know how to render
  the different JSON objects your server can send back.

* you hook up the views to the JSON objects using the iface.

* you can then render a view for an object on a DOM *element* by using
  a special ``render`` extension Obviel adds to jQuery.

All this is pretty dense, so we'll go into much more detail about this
now.

How to include Obviel on your web page
--------------------------------------

Rendering a view
----------------

We'll start with the last bit first: how do we actually render a
*view* for an *object* on an *element*?

A view is a JavaScript component that can *render* its data into the
browser DOM tree. This is done using by calling the function render on
the result of a JQuery selector::

  $('#foo').render(model);

This will look up a view for the JavaScript object ``model`` and then
ask that view to render the model on the element indicated by the
jQuery selector ``#foo``. 

Typically we use selectors that only match a single element, but if we
use a selector that matches more than one element, view lookup is
performed multiple times, once for each matching element.

Now let's look into the pieces in more detail. 

What is model? It's just a JavaScript object::

  var model = {
    'name': 'World'
  };

Typically with Obviel models are JavaScript objects generated as JSON
on the server, but you could basically use any JavaScript object, as
long as it provides an *iface*.

In Obviel a model declares what type of model it is using the
``ifaces`` property::

  var model = {
    ifaces: ['example'],
    'name': 'World'
  };

As you can see, ``ifaces`` is a list of ifaces that this object
declares -- typically only one is enough. We'll have more to say about
this later, but this will do for now.

What is a view? It's a special JavaScript object registered with
Obviel that at minimum says how to render a model on an element::

  obviel.view({
     iface: 'example',
     render: function() {
        this.el.text("Hello " + this.obj.name + "!");
     }
  });

So imagine we have the following HTML in the browser DOM::

  <div id="foo"></div>

What happens when you invoke the following?

  $('#foo').render(model);

The DOM will be changed so it reads this::

  <div id="foo">Hello World!</div>

So, it has rendered ``"Hello World!"``, where ``World`` comes from the
``name`` property of the model object being rendered.

The steps taken are:

* Obviel looks at the ``ifaces`` attribute of the model being
  rendered, in this case ``[`example`]``.

* Obviel looks up the view registered for the iface ``example`` in its
  view registry.

* Obviel creates a clone of the registered view object from this view
  that has as its ``el`` property the element being rendered on, and
  ``obj`` property the object being rendered.

* call the ``render`` method on the view.

* the ``render`` method then does whatever it wants, in particular
  manipulating the DOM using jQuery, as we do here to set the text of
  the div.

Rending sub-objects
-------------------

.. sidebar:: How Partitioning into Views Helps

  Just to make sure to help you to convince view partitioning is good,
  we'll throw some big concepts at you. View partitioning aids:

  * comprehension - each view can be understood on its own, without
    having to read through a mass of other code.

  * reuse - views can be reused in other contexts.

  * pluggability - we can easily plug in different views into the
    ``page``, just by changing our code.

  * server control - the server can control how the page is composed.

  * loose coupling between server and client - the server code still
    does not need to have intimate knowledge of what the client code
    does -- just the ifaces it understands and what attributes are
    expected on an object with a certain iface.

  And all these are Good Things.

When presenting a complicated web page, it makes sense to split the underlying
objects that this web page represents into individual sub objects. So,
you might for instance have a JSON structure like this::

  { 
    ifaces: ['page'],
    parts: [
       { 
         ifaces: ['text'],
         text: "Hello world"
       },
       { 
         ifaces: ['list'],
         entries: ['foo', 'bar', 'baz']
       }
    ]
  }

This has an outer JSON object with the iface ``page``, and in there there
are two parts, one of iface ``text`` and one of iface ``list``.

How would you set out to render such a thing with Obviel views?
Instead of creating one big view that does everything, we can
decompose this into a number of sub-views. Let's first create a view
for the ``text`` iface::

  obviel.view({
     iface: 'text'
     render: function() {
        var p_el = this.el.append('<p>');
        p_el.text(this.obj.text);
     }
  });

This view adds a ``p`` element to the DOM under which it is rendered,
and renders the ``text`` property of the underlying object into it.

We'll also create a view for ``list``::

  obviel.view({
     iface: 'list'
     render: function() {
        var self = this;
        var ul_el = self.el.append('<ul>');
        $.each(self.obj.entries, function(index, entry) {
           var li_el = ul_el.append('<li>');
           li_el.text(entry);
        });
     }
  });

This creates a ``ul`` element in the DOM and renders each entry in the
``entries`` list as a ``li`` element with text in it. Note the use of
the common JavaScript technique of assigning ``this`` to another local
variable, ``self`` by convention in Obviel code, so we have an easy
reference to it in the nested functions we define inside.

Now let's create a view that renders all the ``page`` iface::

  obviel.view({
     iface: 'page',
     render: function() {
        var self = this;
        $.each(self.obj.parts, function(index, part) {
           var div_el = self.el.append($('<div>');
           div_el.render(part);
        });
     }
  });

This view creates a ``div`` for each part in the ``parts``
property. You can see how delegation to sub-views comes in: we render
each part individually. You can also see something else: the ``page``
view has no knowledge of what these sub views are, and could render
any list of them -- it's entirely dependent on the object it is asked
to render.

Partitioning code into views is useful: it's the Obviel way. You'll
find it makes your code a lot easier to manage.

Obviel and hyperlinks
---------------------

.. sidebar:: True REST

  In an REST application design, the client does not have particular
  knowledge about the URLs the server presents -- instead the server is
  in control of the URL space and sends information about URLs to the
  client. This is the way normal web browsing works too -- the web
  browser does not know about particular hyperlinks, but instead the
  user just clicks on links in web pages it retrieves from the
  server. This principle is caled `Hypermedia as the Engine of
  Application State`_.

  In many practical applications that are otherwise RESTful this
  principle is not followed -- the JavaScript code has intimate
  knowledge about what URLs the server has available and this
  structure is hardcoded in the JavaScript code base. This creates a
  tighter coupling between client and server code, and that sucks.

  If it sucks, why do people do such things? Because it's easier to
  write such code. The asynchronous nature of AJAX means that when you
  try to do it the right way, you tend to end up with a big nasty ball
  of nested functions; callbacks within callbacks within callbacks.

  But Obviel makes it dirt simple to let the server be in control of
  URLs - it's actually *easier* to write client-side code this way
  with Obviel, as much of the nitty-gritty about Ajax requests is
  handled by Obviel itself.
  
  On the server, we recommend you use a web framework that offers some
  help in generating URLs for models and views. But even if you can't
  use such a framework, it's still much better to only have to
  hardcode the knowledge about URLs in the server code, and not in the
  client *too*.

  .. _`Hypermedia as the Engine of Application State`: http://en.wikipedia.org/wiki/HATEOAS

  .. _REST: http://en.wikipedia.org/wiki/Representational_state_transfer

We saw how Obviel can be asked to render JavaScript objects. We also
saw how you can compose views together by composing JavaScript objects
together and then having views defer to each other. But the server
code doesn't have to send a whole composed object to the client at
once - sometimes that's too cumbersome (the server state changes), and
sometimes accessing all the data on the server all at once to send to
the client is just too costly. Obviel has a way out: you can hyperlink
objects together using URLs, much like how web pages are hyperlinked
together.

Obviel can render URLs just like it can render ojbects. When you pass
a string to the ``render`` method instead of an object, Obviel will
interpret it as a URL. It will send a GET request to the server to
fetch a JSON object from that URL, and then render that object. For
example::

  $('#foo').render('http://example.com/somejson');

will fetch the JSON from ``http://example.com/somejson``, and then
call ``render`` on that object::

  $('#foo).render(retrieved_obj)

This behavior of Obviel allows you to create a hyperlinked structure
of JavaScript objects. We can demonstrate that using the ``page`` view
we created before. We'll show it here again, unchanged::

  obviel.view({
     iface: 'page',
     render: function() {
        var self = this;
        $.each(self.obj.parts, function(index, part) {
           var div_el = self.el.append($('<div>');
           div_el.render(part);
        });
     }
  });

We also leave the other views to render ``text`` and ``list`` ifaces
unchanged.

Instead of putting full-fledged objects in the ``parts`` array, you can
also put hyperlinks in there. Consider the following object::

  { 
    ifaces: ['page'],
    parts: [
       'http://example.com/hello',
       'http://example.com/some_list'
       ]
  }

and then under the ``http://example.com/hello`` URL we return this::

  { 
    ifaces: ['text'],
    text: "Hello world"
  }

and under the ``http://example.com/some_list`` URL we return this::

  { 
    ifaces: ['list'],
    entries: ['foo', 'bar', 'baz']
  }

Rendering this ``page`` object will result in the same web page as
before - Obviel will automatically request the underlying URLs and
render the objects.

So Obviel's understanding of hyperlinks gives us more cool things:

* more flexibility -- you can create URLs that return an object with a
  *different* iface depending on the circumstances, changing the
  *behavior of the user interface on the fly.

* more loose coupling between server and client - Obviel's
  understanding of hyperlinks increases your ability to create such
  loose coupling.

* easier to create truly RESTful applications - see the sidebar for
  more info on why that's good.


View lookup and registration
----------------------------

Another important ingredient in Obviel that allows loose coupling
between client and server is dynamic view lookup for models. The
primary mechanism of lookup is by the ``iface`` marker on the model. A
model can declare with an iface what kind of model it is, and this way
a view can declare what kind of model it is associated with.

An ``iface`` is in essence just a string marker::

  var elephant = {
    ifaces: ['animal'],
    color: 'grey'
  };

  var lion = {
    ifaces: ['animal'],
    color: 'golden'
  };

Each model can -- and should -- declare what kind of model it is using
these string markers.

When a view is registered, the iface can be provided::

  obviel.view({
     iface: 'animal',
     render: function() {
       this.el.text('The animal is ' + this.obj.color);
     };
  });

If you now render a model that declares iface ``animal``, the view
will be used::

  $('#animal').render(elephant);

will render in the element indicated by ``#animal`` the text::

  The animal is grey

and this::

  $('#animal').render(lion);

will render like this::

  The animal is golden

In some cases an iface is not enough, and you can further distinguish
views by name. The name is really only useful for when you want to
have different ways of rendering the same object (or URL), depending
on where a user clicks, or what tab is open, etc. Here's an example::

  obviel.view({
    iface: 'animal',
    name: 'alternate',
    render: function() {
      this.el.text("Color of animal is: " + this.obj.color);
    };
  });

This named view can be explicitly invoked by passing its name as
a second argument to the ``render`` function::

  $('#animal').render(elephant, 'alternate');

will result in::
  
  Color of animal is: grey

As said before, names are optional, and aren't used very often. By
default the name ``default``.

The iface declaration for a view is optional too, though you should
usually provide it. If you leave out an iface in a view registration
you register a fallback view for all objects.

Note that the model attribute name is ``ifaces`` while the view
attribute name is ``iface``. This makes sense - a model may have more
descriptions of what the data is, but a view only knows how to render
one type of data - but may be a cause of errors that is easy to
overlook.

Attributes available on views
-----------------------------

When you render a view, a view instance is created that has several
useful attributes which you can access through ``this`` in the
``render`` function of a view. We've seen some of them before, but
we'll go through them systematically now.

el
++

The element that this view is being rendered on. This is a jQuery
object, so all the usual jQuery functional will work. This is where
the view expresses itself during rendering: it adds sub-elements to
this element, or changes its ``text()`` value, hooks up event
handlers, etc.

obj
+++

This is the model that the view is supposed to render. You access it
for attributes and such that drive the rendering process on the
element.

name
++++

This is the name of the current view. By default it is ``default``.

html and html_url
-----------------

A view can be configured so that it renders a piece of static HTML
before the ``render`` function is called. You can do this by adding a
``html`` attribute to the view. Here's an example::

  obviel.view({
     ifaces: ['foo'],
     html: '<div class="a_class">Some HTML</div>',
     render: function() {
        var el = $('.a_class', this.el);
        el.text("Changed the text!");
     }
  });

You can also refer to a static HTML resource on the server using the
``html_url`` attribute::

  obviel.view({
     ifaces: ['foo'],
     html_url: 'http://www.example.com/some.html',
     render: function() {
        // ...
     }
  });

The HTML referred to by ``html_url`` will be cached by the system.

``render`` is called after the HTML is loaded into the element, and
can place data from the model into the rendered element, register
event handlers, etc.

Instead of supplying the HTML directly during the view registration,
you can also let the server supply the HTML in the model. If the
object to be rendered has a ``html`` or ``html_url`` attribute those
will be interpreted first.

If both ``html`` and ``html_url`` are found on a view or a model, the
``html`` attribute has precedence. The ``html`` and ``html_url``
attributes of the model have precedence over any defined on the view.

jsont and jsont_url: JSON template
----------------------------------

A combination of static HTML and jQuery scripting is often dynamic
enough, but sometimes a client-side template language is convenient. 
Obviel offers extensible support for template languages, but by
default support for `JSON template`_ is included.

.. _`JSON template`: https://json-template.googlecode.com/svn/trunk/doc/Introducing-JSON-Template.html

The attributes ``jsont`` and ``jsont_url`` work much like ``html`` and
``html_url`` and can be provided both by the view and the model. Let's
look at an example::

  obviel.view({
    iface: 'person',
    jsont: '<div>{name}</div>'
  });

  $('#somediv').render({
    iface: 'person',
    name: 'John'});

This will result in::

  <div>John</div>

When rendering a JSON template, the object being rendered is combined
with the template and the resulting HTML is inserted into the element
that ``render`` was invoked for.

Callbacks
---------

Sometimes it is useful to know when a view is done rendering This
especially useful when you are writing automated tests that involve
Obviel; the Obviel test suit itself is a good example. You can supply
a callback by passing a function to the ``render`` method::

  el.render(obj, function() { alert("Callback called!") };

You can use ``this`` in the view to refer to the view that invoked the
callback.

subviews
--------

Often a view is composed out of other views. For instance, an outer
view could render a whole page, and sections of the page are rendered
using sub-views. These may in turn use other views for smaller
fragments on the page. Doing this reduces coupling between application
components, and encourages the creation of reusable views.

You can invoke sub-views by hand in a render method, like this::

  obviel.view({
    render: function() {
       $('.foo', this.el).render(this.obj.attr);
    }
  });

This will render a subview on the element matched by class ``foo`` for
the model indicated by ``this.obj.attr``. ``this.obj.attr`` may be a
sub-object or a URL referring to another object.

Doing this by hand is not too bad, but the Obviel also allows a
shorter, declarative way to express this::

  views.view({
    subviews: {
      '.foo': 'attr'
    }
  });

This does the same thing as the previous example.

The ``subviews`` attribute, if available, should define a mapping from
JQuery selector to attribute name. After the main ``render()``
function of the view has been executed, any subviews that are defined
will be resolved.

So, if you have this view::

   views.view({
     subviews: {
        '#alpha': 'alpha',
        '#beta': 'beta_url'
   });

And render it with the following context object::

  {
   alpha: {text: 'foo'},
   beta_url: '/beta.json'
  }

the system will, in effect, call::

  $('#alpha', this.el).render({text: 'foo'})

and::

  $('#beta', this.el).render('/beta.json') 

If you want to invoke a subview with a specific name, you can provide
a name for subviews by passing an array instead of a string as the
value of the subviews mapping::

  views.view({
    subviews: {
        '#selector': ['attr', 'name']
    }
  });

Here, a subview is registered for the selector '#selector', the data is looked
up on the context object using attribute name 'attr', and the view is looked
up using name 'name'.

Note that if a callback is provided to render(), it will be called after the
main view and all its subviews are done rendering.

events: view event registration
-------------------------------

Typically a view will need to attach event handlers to elements
rendered by the view. You can do this by hand::

  obviel.view({ 
     iface: 'foo', 
     render: function() {
        var self = this;
        self.el.click(function() {
           self.el.text("clicked!");
        });
     }
  });

Like with subviews, Obviel allows a declarative way to hook up events. Here
is the equivalent of the above::

  obviel.view({ 
    iface: 'foo',
    render: function() {},
    events: {
       'click': function(ev) {
           ev.view.el.text('clicked!");
       }
    }
  });

Like standard jQuery, the event handler gets an event object, but this
object will have a special attribute ``view`` which is the view that
this event is associated with.

There is another way to express this::

  obviel.view({
    iface: 'foo',
    render: function() {},
    events: {
       'click': 'handle_click'
       }
    }
    handle_click: function(ev) {
       this.el.text('clicked!");
    }
  });

In this case instead of directly hooking up the event handler, we
refer to a method of the view itself as the event handler. You can
refer to the view and its attributes using ``this`` just like you do
with ``render``. The event handler also receives the usual event
object as the first argument.

All declaratively defined events are registered after the view has
been rendered.

cleanup
-------

XXX

element association
--------------------

XXX

events sent by obviel
---------------------

XXX

Additional methods
------------------

A view may supply extra methods that it calls itself to assist in the
rendering of the view and setting up of event handlers::

  obviel.view({
    render: function() {
      this.foo();
    },
    foo: function() {
      // ...extra work...
    }
  });

Similarly additional attributes may be provided.

View inheritance
----------------

While in many cases the additional methods strategy as described
previously is sufficient, it is sometimes useful to be able to inherit
from a base view. The Obviel form system is a good example of this.

To this end it's useful to understand that the following registration::

  obviel.view({
    render: function() { ... }
  });

is in fact a shorthand for this registration::

  obviel.view(new obviel.View({render: function() { ... }}));

Obviel automatically creates a basic Obviel ``View`` if a bare
object is passed to the ``view`` registration function.

You can however also create new view objects by subclassing ``View``
yourself::

  var DivView = function(settings) {
    var d = {
      html: '<div></div>'
    };
    $.extend(d, settings);
    obviel.View.call(this, d);
  };

  DivView.prototype = new obviel.View;

  DivView.render = function() {
    // ...
  };

Now the new view can be registered like this::

  obviel.view(new DivView());

Iface extension
---------------

It is sometimes useful to be able to register an iface more
generically, for a whole selection of related objects. We may have
more particular ``person`` objects such as ``employee``,
``contest_winner``, etc, but if we register a view for ``person``
objects we want it to automatically apply to those other types of
objects as well, unless we registered more specific views for the
latter.
 
Let's consider the following object describing a person::

  >>> bob = {name: 'Bob', location: 'US', occupation: 'skeptic', 
  ...        ifaces: ['person']}

  >>> obviel.ifaces(bob)
  ['person', 'base', 'object']

XXX check whether this is truly returned

So far nothing new. But ifaces themselves can have an extension
relationship with each other: iface ``b`` can be declared to
extend iface ``a``. We've already seen an example of this, because
``person`` automatically extends the base iface ``base``.

If a view is declared for a certain iface, it is also automatically
declared for all ifaces that extend that iface.

So let's imagine we have an iface ``employee`` that extends the
``person`` iface. We can tell the system about it like this::

  >>> obviel.extendsIface('employee', 'person')

An iface may extend an arbitrary amount of other ifaces, but circular
relationships are not allowed. The ``obviel.ifaces`` function knows
about extensions. So, let's say that we have an ``employee`` object::

  >>> employee = {name: 'Bob', location: 'US', occupation: 'skeptic',
  ...             wage: 0, ifaces: ['employee']}

Since we said before that any ``employee`` is also a ``person``, the
following is true::

  >>> views.ifaces(employee)
  ['employee', 'person', 'base', 'object']

Note that interfaces are sorted by topological sort, with the most
specific interfaces at the start. When looking up a view for an
object, this is useful to ensure that the views registered for the
most specific interfaces are found first.
