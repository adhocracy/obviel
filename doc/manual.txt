Obviel: Object/View/Element for jQuery
======================================

Introduction
------------

Obviel is a model/view abstraction for JavaScript that helps you
improve the structure of JavaScript applications. It's built with
jQuery. It is especially geared towards RESTful rich client
applications, but should work for any website that uses
JavaScript. Obviel's particular strength is its support for *loose
coupling* between client and server: the JavaScript codebase on the
client is relatively independent from the server implementation.

Obviel provides you with a model/view architecture on the client side,
with dynamic view lookup based on the type (or in Obviel terminology,
the *iface*) of a JavaScript object.

In Obviel, a *model* is a JavaScript object, typically retrieved
through JSON. An Obviel *view* is an object that knows how to
represent such a model object into the browser DOM. Views are
connected to *elements*.

In addition to its basic architecture, Obviel provides support for
client-side templating and client-side form construction.

Rendering a view
----------------

A view is a component that can *render* its data into the DOM
tree. This is done using by calling the function render on the result
of a JQuery selector::

  $('#foo').render(model);

This will represent ``model`` for the element indicated by the
selector ``#foo``. Typically we use selectors that only match a single
element, but if we use a selector that matches more than one element,
view lookup is performed multiple times, once for each matching
element, and the callback is called each time a view is rendered for
such an element.

What is model? It's just a JavaScript object::

  var some_model = {
    'an': 'attribute'
  };

In Obviel models typically declare what type of model they are using
the ``ifaces`` declaration, more about that later::

  var some_model = {
    ifaces: ['example_model'],
    'an': 'attribute'
  };

What is a view? It's a special JavaScript object registered with
Obviel that at minimum says how to render a model::

  obviel.view({
     iface: 'example_model',
     render: function() {
        this.el.text("Hello world!");
     }
  });

Obviel and hyperlinks
---------------------

When you ask Obviel to render a string, Obviel will interpret it as a
URL. In this case, it will send a GET request to the server to fetch a
JSON object from that URL, and then render it::

  $('#foo').render('http://example.com/somejson');

This allows you to create a hyperlinked structure of JavaScript
objects: you can send back an object that contains sub-objects or URLs
to other objects elsewhere on the server. These objects can in turn
be rendered by the code defined for the view (creating 'sub-views').

Example::

   var foo = { 
     'alpha': { 'a': 3 },
     'beta': 'http://www.example.com',
     'gamma': 'relative_url' 
   };

If you now do::

  $(el).render(foo.alpha);

Obviel will try to render the sub-object ``{'a': 3}``.

but you can also ask Obviel to render ``beta``::

  $(el).render(foo.beta);

in which case it will fetch the object indicated by the
 ``http://www.example.com`` URL and then render it. 

You can also indicate a relative URL (relative to the web page that
includes this script)::

  $(el).render(foo.gamma);

Obviel's understanding of hyperlinks is one of the ingredients that
allow loose coupling between client and server.

View lookup and registration
----------------------------

Another important ingredient in Obviel that allows loose coupling
between client and server is dynamic view lookup for models. The
primary mechanism of lookup is by the ``iface`` marker on the model. A
model can declare with an iface what kind of model it is, and this way
a view can declare what kind of model it is associated with.

An ``iface`` is in essence just a string marker::

  var elephant = {
    ifaces: ['animal'],
    color: 'grey'
  };

  var lion = {
    ifaces: ['animal'],
    color: 'golden'
  };

Each model can -- and should -- declare what kind of model it is using
these string markers.

When a view is registered, the iface can be provided::

  obviel.view({
     iface: 'animal',
     render: function() {
       this.el.text('The animal is ' + this.obj.color);
     };
  });

If you now render a model that declares iface ``animal``, the view
will be used::

  $('#animal').render(elephant);

will render in the element indicated by ``#animal`` the text::

  The animal is grey

and this::

  $('#animal').render(lion);

will render like this::

  The animal is golden

In some cases an iface is not enough, and you can further distinguish
views by name. The name is really only useful for when you want to
have different ways of rendering the same object (or URL), depending
on where a user clicks, or what tab is open, etc. Here's an example::

  obviel.view({
    iface: 'animal',
    name: 'alternate',
    render: function() {
      this.el.text("Color of animal is: " + this.obj.color);
    };
  });

This named view can be explicitly invoked by passing its name as
a second argument to the ``render`` function::

  $('#animal').render(elephant, 'alternate');

will result in::
  
  Color of animal is: grey

As said before, names are optional, and aren't used very often. By
default the name ``default``.

The iface declaration for a view is optional too, though you should
usually provide it. If you leave out an iface in a view registration
you register a fallback view for all objects.

Note that the model attribute name is ``ifaces`` while the view
attribute name is ``iface``. This makes sense - a model may have more
descriptions of what the data is, but a view only knows how to render
one type of data - but may be a cause of errors that is easy to
overlook.

Attributes available on views
-----------------------------

When you render a view, a view instance is created that has several
useful attributes which you can access through ``this`` in the
``render`` function of a view. We've seen some of them before, but
we'll go through them systematically now.

el
++

The element that this view is being rendered on. This is a jQuery
object, so all the usual jQuery functional will work. This is where
the view expresses itself during rendering: it adds sub-elements to
this element, or changes its ``text()`` value, hooks up event
handlers, etc.

obj
+++

This is the model that the view is supposed to render. You access it
for attributes and such that drive the rendering process on the
element.

name
++++

This is the name of the current view. By default it is ``default``.

html and html_url
-----------------

A view can be configured so that it renders a piece of static HTML
before the ``render`` function is called. You can do this by adding a
``html`` attribute to the view. Here's an example::

  obviel.view({
     ifaces: ['foo'],
     html: '<div class="a_class">Some HTML</div>',
     render: function() {
        var el = $('.a_class', this.el);
        el.text("Changed the text!");
     }
  });

You can also refer to a static HTML resource on the server using the
``html_url`` attribute::

  obviel.view({
     ifaces: ['foo'],
     html_url: 'http://www.example.com/some.html',
     render: function() {
        // ...
     }
  });

The HTML referred to by ``html_url`` will be cached by the system.

``render`` is called after the HTML is loaded into the element, and
can place data from the model into the rendered element, register
event handlers, etc.

Instead of supplying the HTML directly during the view registration,
you can also let the server supply the HTML in the model. If the
object to be rendered has a ``html`` or ``html_url`` attribute those
will be interpreted first.

If both ``html`` and ``html_url`` are found on a view or a model, the
``html`` attribute has precedence. The ``html`` and ``html_url``
attributes of the model have precedence over any defined on the view.

jsont and jsont_url: JSON template
----------------------------------

A combination of static HTML and jQuery scripting is often dynamic
enough, but sometimes a client-side template language is convenient. 
Obviel offers extensible support for template languages, but by
default support for `JSON template`_ is included.

.. _`JSON template`: https://json-template.googlecode.com/svn/trunk/doc/Introducing-JSON-Template.html

The attributes ``jsont`` and ``jsont_url`` work much like ``html`` and
``html_url`` and can be provided both by the view and the model. Let's
look at an example::

  obviel.view({
    iface: 'person',
    jsont: '<div>{name}</div>'
  });

  $('#somediv').render({
    iface: 'person',
    name: 'John'});

This will result in::

  <div>John</div>

When rendering a JSON template, the object being rendered is combined
with the template and the resulting HTML is inserted into the element
that ``render`` was invoked for.

Callbacks
---------

Sometimes it is useful to know when a view is done rendering This
especially useful when you are writing automated tests that involve
Obviel; the Obviel test suit itself is a good example. You can supply
a callback by passing a function to the ``render`` method::

  el.render(obj, function() { alert("Callback called!") };

You can use ``this`` in the view to refer to the view that invoked the
callback.

subviews
--------

Often a view is composed out of other views. For instance, an outer
view could render a whole page, and sections of the page are rendered
using sub-views. These may in turn use other views for smaller
fragments on the page. Doing this reduces coupling between application
components, and encourages the creation of reusable views.

You can invoke sub-views by hand in a render method, like this::

  obviel.view({
    render: function() {
       $('.foo', this.el).render(this.obj.attr);
    }
  });

This will render a subview on the element matched by class ``foo`` for
the model indicated by ``this.obj.attr``. ``this.obj.attr`` may be a
sub-object or a URL referring to another object.

Doing this by hand is not too bad, but the Obviel also allows a
shorter, declarative way to express this::

  views.view({
    subviews: {
      '.foo': 'attr'
    }
  });

This does the same thing as the previous example.

The ``subviews`` attribute, if available, should define a mapping from
JQuery selector to attribute name. After the main ``render()``
function of the view has been executed, any subviews that are defined
will be resolved.

So, if you have this view::

   views.view({
     subviews: {
        '#alpha': 'alpha',
        '#beta': 'beta_url'
   });

And render it with the following context object::

  {
   alpha: {text: 'foo'},
   beta_url: '/beta.json'
  }

the system will, in effect, call::

  $('#alpha', this.el).render({text: 'foo'})

and::

  $('#beta', this.el).render('/beta.json') 

If you want to invoke a subview with a specific name, you can provide
a name for subviews by passing an array instead of a string as the
value of the subviews mapping::

  views.view({
    subviews: {
        '#selector': ['attr', 'name']
    }
  });

Here, a subview is registered for the selector '#selector', the data is looked
up on the context object using attribute name 'attr', and the view is looked
up using name 'name'.

Note that if a callback is provided to render(), it will be called after the
main view and all its subviews are done rendering.

events: view event registration
-------------------------------

Typically a view will need to attach event handlers to elements
rendered by the view. You can do this by hand::

  obviel.view({ 
     iface: 'foo', 
     render: function() {
        var self = this;
        self.el.click(function() {
           self.el.text("clicked!");
        });
     }
  });

Like with subviews, Obviel allows a declarative way to hook up events. Here
is the equivalent of the above::

  obviel.view({ 
    iface: 'foo',
    render: function() {},
    events: {
       'click': function(ev) {
           ev.view.el.text('clicked!");
       }
    }
  });

Like standard jQuery, the event handler gets an event object, but this
object will have a special attribute ``view`` which is the view that
this event is associated with.

There is another way to express this::

  obviel.view({
    iface: 'foo',
    render: function() {},
    events: {
       'click': 'handle_click'
       }
    }
    handle_click: function(ev) {
       this.el.text('clicked!");
    }
  });

In this case instead of directly hooking up the event handler, we
refer to a method of the view itself as the event handler. You can
refer to the view and its attributes using ``this`` just like you do
with ``render``. The event handler also receives the usual event
object as the first argument.

All declaratively defined events are registered after the view has
been rendered.

cleanup
-------

XXX

element association
--------------------

XXX

events sent by obviel
---------------------

XXX

Additional methods
------------------

A view may supply extra methods that it calls itself to assist in the
rendering of the view and setting up of event handlers::

  obviel.view({
    render: function() {
      this.foo();
    },
    foo: function() {
      // ...extra work...
    }
  });

Similarly additional attributes may be provided.

View inheritance
----------------

While in many cases the additional methods strategy as described
previously is sufficient, it is sometimes useful to be able to inherit
from a base view. The Obviel form system is a good example of this.

To this end it's useful to understand that the following registration::

  obviel.view({
    render: function() { ... }
  });

is in fact a shorthand for this registration::

  obviel.view(new obviel.View({render: function() { ... }}));

Obviel automatically creates a basic Obviel ``View`` if a bare
object is passed to the ``view`` registration function.

You can however also create new view objects by subclassing ``View``
yourself::

  var DivView = function(settings) {
    var d = {
      html: '<div></div>'
    };
    $.extend(d, settings);
    obviel.View.call(this, d);
  };

  DivView.prototype = new obviel.View;

  DivView.render = function() {
    // ...
  };

Now the new view can be registered like this::

  obviel.view(new DivView());

Iface extension
---------------

It is sometimes useful to be able to register an iface more
generically, for a whole selection of related objects. We may have
more particular ``person`` objects such as ``employee``,
``contest_winner``, etc, but if we register a view for ``person``
objects we want it to automatically apply to those other types of
objects as well, unless we registered more specific views for the
latter.
 
Let's consider the following object describing a person::

  >>> bob = {name: 'Bob', location: 'US', occupation: 'skeptic', 
  ...        ifaces: ['person']}

  >>> obviel.ifaces(bob)
  ['person', 'base', 'object']

XXX check whether this is truly returned

So far nothing new. But ifaces themselves can have an extension
relationship with each other: iface ``b`` can be declared to
extend iface ``a``. We've already seen an example of this, because
``person`` automatically extends the base iface ``base``.

If a view is declared for a certain iface, it is also automatically
declared for all ifaces that extend that iface.

So let's imagine we have an iface ``employee`` that extends the
``person`` iface. We can tell the system about it like this::

  >>> obviel.extendsIface('employee', 'person')

An iface may extend an arbitrary amount of other ifaces, but circular
relationships are not allowed. The ``obviel.ifaces`` function knows
about extensions. So, let's say that we have an ``employee`` object::

  >>> employee = {name: 'Bob', location: 'US', occupation: 'skeptic',
  ...             wage: 0, ifaces: ['employee']}

Since we said before that any ``employee`` is also a ``person``, the
following is true::

  >>> views.ifaces(employee)
  ['employee', 'person', 'base', 'object']

Note that interfaces are sorted by topological sort, with the most
specific interfaces at the start. When looking up a view for an
object, this is useful to ensure that the views registered for the
most specific interfaces are found first.
