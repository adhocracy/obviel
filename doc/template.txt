Obviel Template
===============

Introduction
------------

Obviel Template integrates with Obviel in an important way: sub-views
can be rendered directly from the template. This allows these views to
respond to events in the standard Obviel way, including responding to
object events. Obviel Template can do this because it's DOM-based, not
text-based. Doing this with a text-based template language (such as
JSON Template) isn't possible, as it isn't aware of DOM elements at
all.

Another powerful feature of Obviel Template is that it supports i18n
markers directly in the template for the purpose of
internationalization (i18n) of template texts. This way automatic
extraction tools can be used to maintain translations of strings in
the template. This feature is inspired by some server-side template
languages (such as Zope Page Templates), but this is not commonly
supported by client-side template languages.

Obviel Template is deliberately a very minimal template
language. Logic should be kept in code, not templates. If you need
logic, preprocess the object that goes into the template instead.

Variables
---------

Obviel-Template supports variable interpolation using ``{}`` markers
in text. It looks like this::

  <p>{content}</p>

If you combine that template with a JavaScript object with the
following structure::

  {
    content: "Hello world!"
  }

it will result in a rendered template like this::

  <p>Hello world!</p>

What if the ``content`` property is not available in the JavaScript
object, and is thus ``undefined``? Obviel Template considers this an
error and the template will fail with a ``RenderError`` exception.

Dotted names in variables
-------------------------

Objects can be nested::

  {
    a: {
      b: "The value"
    }
  }

You can indicate such nested values in a variable using a dotted
name::

  <p>{a.b}</p>

Rendering the template with the object will result in this::

  <p>The value</p>

If you refer to a dotted name that does not exist in the data, this is
an error and the template won't render; you get a ``RenderError``
exception.

Dotted names also work in directives like ``data-with``, ``data-if``
and ``data-each``, which we'll see next.

``data-with`` for scope control
-------------------------------

You can change the object in which variables are found with the
``data-with`` directive. Given the same nested structure as before::

  {
    a: {
      b: "The value"
    }
  }

you can express the template like::

  <div>
    <p data-with="a">{b}</p>
  </div>

Rendering the template with the object will result in this::

  <div>
    <p>The value</p>
  </div>

``data-with="a"`` indicates that within the ``p`` element, lookups
will be performed in the ``b`` object primarily (that is the *scope*
of that element).


``data-with`` must point to an object; it cannot point to strings or
arrays or other values, and cannot point to a missing value either:
these are ``RenderError`` errors.

``data-if`` for conditionals
----------------------------

Sometimes you want to include an element only if a given value is true
or not. For the purposes of ``data-if``, a value is *false* if:

* it is the ``false``

* it is ``null``

* it is ``undefined``

* it is ``0``

* it is an empty string ``""``

* it is an empty array

* the value is missing entirely

Otherwise, the value is considered *true*.

With ``!``, the behavior of ``data-if`` can be reversed: values that 
evaluate to false *will* be included.

Consider this template::

  <p data-if="person">Hello {person.name}!</p>
  <p data-if="!person">{person.name} is not present</p>

Here's a data structure with ``person`` present::

  {
    person: {
      name: "Evan"
    }
  }

rendering the template will result in this::

  <p>Hello Evan!</p>

but if you have a data structure without ``person`` present, such as this::

  { 

  }

the template will render like this::

  <p>Evan is not present</p>

``data-each`` for repetition
----------------------------

If you point to an array with ``data-each``, it will render each entry
in the array into the DOM. So with a data structure like this::

  {
    persons: [
       {
         name: "Bob"
       },
       {
         name: "Steven"
       }
    ]
  }

and a template like this::
 
  <ul>
    <li data-each="persons">{name}</li>
  </ul>

the result will be this::

  <ul>
    <li>Bob</li>
    <li>Steven</li>
  </ul>
 
Note that ``data-each`` changes the scope (like
``data-with``). ``data-each`` changes the object in which the
variables are looked up to each entry in the array, one by one.

If the array is empty, nothing will be rendered at all. So, this
data::

  {
    persons: [
    ]
  }

will result in this::

  <ul>
  </ul>

You can use the special variable ``@.`` to render simple arrays where
each item is not an object in itself. For instance::

  {
    persons: [
      "Bob", "Steven", "Jay"
    ]
  }

and this template::

  <ul>
    <li data-each="persons">{@.}</li>
  </ul>

will render like this::

  <ul>
    <li>Bob</li>
    <li>Steven</li>
    <li>Jay</li>
  </ul>

Interpolating the current object: ``@.``
----------------------------------------

Sometimes you want to interpolate the current object or array into the
document (as JSON), mostly for debugging purposes. For this you can
use ``{@.}`` as well.

Consider this data::

  {
    title: "Foo"
  }

and this template::

  <div>
    {@.}
  </div>

Rendering the template with the data will result in this::

  <div>
    {
      title: "Foo"
    }
  </div>

Nested scoping
--------------

Values in outer scopes are available for variables in inner
scopes. Consider this structure of objects::

  {
   a: {
     b: "The value"
   },
   c: "Outer value"
   d: {
     e: "Value in outer object"
   }
  }

In the scope ``a``, we can still access ``c`` and ``d`` (and even
``a`` again)::

 <p>b in outer scope: {a.b}</p>
 <p>c in outer scope: {c}</p>
 <p>e in outer scope: {e}</p>
 <p data-with="a">b in scope a: {b}</p>
 <p data-with="a">c in scope a: {c}</p>
 <p data-with="a">e in scope a: {d.e}</p>
 <p data-with="a">b in a in scope a: {a.a.b}</p>

But if you redefine a name in an inner scope, you cannot access the
value in the outer scope::

  {
    a: {
      b: 'redefined'
    }
    b: 'original'
  }

  <p data-with="a">b in scope a: {b}</p>

will therefore get you::

  <p>b in scope a: redefined</p>

``data-view``
-------------

Consider the following data::

  {
    greeting: "Hello",
    who: {
      iface: 'person',
      name: "Pat Pending",
      url: "http://www.example.com/pat_pending"
    }
  }

and this template::

  <p>{greeting} <span><a data-with="who" href="{url}">{name}</a></span></p>

it will render like this::

  <p>Hello <span><a href="http://www.example.com/pat_pending">Pat Pending</a></span></p>

This works. But we could also arrange our code so that we have a view
for the ``person`` iface and use that instead. The advantage of that
is that we could reuse this view in other places, and in addition we
can use an Obviel view to hook up to events and so on. Let's consider
a view::

  obviel.view({
     iface: 'person',
     obvt: '<a href="{url}">{name}</a>'
  });

This is a view for the iface ``person``. We use the Obviel Template
(indicated by ``obvt``) to render the view.

Now we can change our template to render ``who`` as a view::

  <p>{greeting} <span data-view="who"></span></p>

The result is still the same::

  <p>Hello <span><a href="http://www.example.com/pat_pending">Pat Pending</a></span></p>

By using ``data-view``, you have made the outer template more generic.
If the object indicated by the name ``who`` has another ``iface``, the
template will still work unchanged. For example, here is a data
structure where ``who`` is a robot::

  {
    greeting: "Greetings",
    who: {
      iface: 'robot',
      designation: "OVL-R 4711",
    }
  }
 
and this is a view for the iface ``robot``::

  obviel.view({
     iface: 'robot',
     obvt: '{designation}'
  });

and here is our template again::

  <p>{greeting} <span data-view="who"></span></p>

when we render the data now, we get this::

  <p>Greetings <span>OVL-R 4711</span></p>

in other words, if you add ``data-view`` to an element ``el`` to
render object ``who``, Obviel Template will do the equivalent of this::

  $(el).render(who);

Sometimes you have multiple views for an ``iface``, distinguished by
name. You can indicate the name used by ``data-view`` with a ``|``
character. Here's another view for ``person`` with the name ``extended``::

  obviel.view({
     iface: 'person',
     name: 'extended',
     obvt: 'The person has the name <a href="{url}">{name}</a>'
  });


and here is how you refer to this ``extended`` view::

  <p>{greeting} <span data-view="who|extended"></span></p>

By default, ``data-view`` looks up a view named ``default`` -- the default
view name for Obviel. If you want to change the way templates look up
views to use another view globally you can do so in JavaScript::

  obviel.template.set_default_view_name('summary');

from now on if you don't specify the view name explicitly, Obviel will
look up views by the name of ``summary`` by default. If you decide to
do this, you would want to do this once per web page before template
rendering takes place, for instance when the page has just been loaded. Note
that this does *not* alter the default view name of Obviel itself when
you use ``el.render(obj)``; this will remain ``default``.

``data-view`` must point to an object. It cannot point to an array or
other value.

Formatters
----------

Besides views to insert HTML, for text manipulation Obviel Template also
supports formatters. Formatters can be registered globally with 
Obviel Template like this::

  obviel.template.register_formatter('upper', function(value) {
     return value.toUpperCase();
  });

This registers a formatter ``upper`` which when used will turn any
string variable to upper case. Here's how we would use it in a template::

  <p>{foo|upper}</p>

if we render this with the data structure::

  {foo: 'hello'}

we'd get the following output::

  <p>HELLO</p>

Again, formatters cannot be used to include HTML, only text; for
including HTML you can use views.

You would register formatters only once per web page before template
rendering takes place, for instance when the page has just been loaded.

id support
----------

Obviel templates should be valid HTML fragments. In valid HTML, a id
should be unique. You can just use ids like for any other HTML::
 
  <div id="foo"></div>

But variables in ids are not allowed, because it would be too easy to
have a HTML fragment with the same id (such ``{my_id}``) in multiple
``id`` attributes. So this is **illegal**::

  <div id="{not_allowed}"></div>

To generate an id, you can instead use the ``data-id`` directive::

  <div data-id="{some_id}"></div>

This works just like any other attribute, so you can put things before
and after the variable::

  <div data-id="prefix{some_id}postfix"></div>

This will generate HTML with proper ``id`` attributes.

Order
-----

You can combine the attributes ``data-if``, ``data-each``,
``data-with``, and ``data-view`` on an element::

  <p data-if="a" data-each="b" data-with="c" data-view="d"></p>

The order of execution is as follows :

* ``data-if``

* ``data-each``

* ``data-with``

* ``data-view`` or ``data-trans``

This order holds no matter in what order you define the attributes. 

``data-trans``, which we'll introduce next, also follows after the
other statements. It's not allowed on an element with ``data-view``.
 
This means that if the value ``a`` is present and true, the ``p``
element will be included in the rendered template (at all). After
this, for each of the entries in ``b`` (so ``b`` scope, iteratively),
we render the object ``d`` in the ``c`` scope with a view.
 
``data-trans`` for i18n
------------------------

Obviel Template offers the ability to write a template that can be
shown in other languages as well: you can *internationalize* a
template. We will discuss the basics of marking up a template so it
can be translated here, but much more detail is in a separate document
about i18n.

If we have a template like this::

 <p data-trans="">Hello world!</p>

we can also show this template in the Dutch language if the appropriate
translation is available::

 <p>Hallo wereld!</p>

``data-trans``` is used to mark up those parts of the template that
should be translatable, such as attributes and texts. These
translatable values can contain variables as well:

  <p data-trans="">Hello {who}!</p>

By default, ``data-trans`` is used to mark the textual content of a
tag for translation. If you want to mark an attribute as translatable
you can do it like this::

  <div data-trans="title" title="Hello" />

You can also mark multiple attributes::

  <div data-trans="title other" title="Hello" other="Something" />

You can indicate attributes *and* textual element content with the
special name ``.``:

  <div data-trans=". title" title="Hello">Contents</div>

``data-trans`` may not be on an element that also has a ``data-view``.

Literals
--------

Injecting the characters ``{`` and ``}`` can be done using a special
markup::

  {@open} 

  {@close}

Unsupported XML constructs
--------------------------

The HTML CDATA section implementation in browsers is so inconsistent we
didn't think it was worth spending time supporting this in templates, given
its limited utility. Obviel Template therefore has undefined behavior in
the presence of one in your template: we recommend you don't use any.

Similarly, process instructions are not supported.
