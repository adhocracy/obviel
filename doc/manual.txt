Obviel: Object/View/Element for jQuery
======================================

Introduction
------------

Obviel is an extension to jQuery that tries to help in improving the
structure of JavaScript applications. It is especially geared towards
'RESTful' rich-client applications, but should work for any website that uses
JavaScript.

Obviel provides you with a model/view architecture on the client side, with
dynamic view lookup based on a data descriptor (called 'iface' in Obviel,
though it is just a marker rather than an interface that describes the whole
data structure). In Obviel, a model is simply a JavaScript object,
typically retrieved through JSON, an Obviel view is an object that knows how
to represent such a model object into the browser DOM.

Some options are made available to help with common use cases, such as form
handling, client-side templating, and iframe embedding of content.

Rendering a view
----------------

A view is a component that can *render* its data into the DOM
tree. This is done using the JQuery mechanism of calling a function,
in this case called 'render', on the result of a JQuery selector::

  $('#foo').render(model);

This will represent ``model`` for the element indicated by the selector
``#foo``. If we use a selector that matches more than one element,
view lookup is performed multiple times, once for each matching
element, and the callback is called each time a view is rendered for
such an element.

Views can also render URLs. In this case, it will send a GET request
to the server to fetch a JSON object from the URL, and then render it::

  $('#foo').render('http://example.com/somejson')

This allows you to create a hyperlinked structure of JavaScript
objects: you can send back an object that contains sub-objects or URLs
to other objects elsewhere on the server. These objects can in turn
be rendered by the code defined for the view (creating 'sub-views').

View lookup and registration
----------------------------

To avoid having to tightly bind a view to a model, Obviel uses 2 seperate
mechanisms: the first involving a marker on the view and model, called
'iface' - since it's rather similar to what interfaces are normally used
for, though they're really just strings - and the second involving an id
for the view, called 'name'.

When a view is registered, both the iface and name can be provided, and when a
view is looked up, it happens on a combination of iface, provided by the model,
and name, provided as an argument to the view function. In most cases, though,
only an iface is provided, the name is really only useful for when you want to
have different ways of rendering the same object (or URL), depending on where
a user clicks, or what tab is open, etc.

The iface is optional, though providing it is highly encouraged except in the
most simple of situations. It it used to tell the system what type of data
a model represents, when a model is passed to render() Obviel uses this
information to find a view which knows how to render such a model based on
this information.

The default name for a view is ``default``, if you want to look up a view
for a different name, say ``x``, it can be provided as a second argument
to the render function::

  $('#foo').render(obj, 'x');

This looks up the view named ``x`` for model obj (so it also checks obj's
iface) and renders it on all elements matching ``$('#foo')``, with the object
as context.

Arguments to render
-------------------

The render function can have up to 4 arguments, the first of which is the
object or URL to render, and the rest depends on what others are provided.
The other arguments are ``name``, ``callback`` and ``errback``, all are
optional, and there's some smartness that checks whether the second argument
is a string or a function to allow leaving out ``name`` and providing
``callback`` as second argument instead.

model
+++++

The first, and only mandatory, argument defines what to render. If it is
of a string type, it's considered a URL that returns a JSON structure
for a model (JSON is the default, thought it's possible to customize),
if it's anything else it's considered a model object.

name
++++

As described above, names are a mechanism to distinguish between multiple views
on the same object. They should be used in moderation and ideally be fairly
generic, like 'default', 'edit', and such, to encourage loose coupling between
code. Typically, a name is used when one or more objects registered on the same
interface need to be rendered in multiple ways.

callback
++++++++

Optionally also a callback function may be provided::

  $('#foo').render(obj, function(element, view, obj) { ... });

The callback will be called after the view is rendered. It receives
three arguments, the first a reference to the element the view is
rendered on, then the view object itself, and the lastly the object
that the view was rendered for. XXX should we make this order
ob/vie/el?

errback
+++++++

Another optional handler that can be passed is for error handling,
and is called if anything goes wrong. Since this is a function just
like callback, there's no magic to determine whether this or callback
is provided, so you will either need to provide both a callback and
an errback, or no errback at all (note that ``null`` can be passed
as callback). Example of calling render with this argument::

  $('#foo').render(obj, function(el, view, obj) {}, function(err) {});

The errback is called with an instance of the exception as its only argument,
and allows customizing error handling, and catching of errors in
asynchronous situations, where otherwise errors are usually silently
ignored. Note that if not provided, the errback will be set to
``views.onerror``, which either console.logs the error (if Firebug is enabled)
or pops up an alert.

View declaration
----------------

A view is declared like this::

  obviel.view({<options>});

Or an actual example::

   obviel.view({
       render: function(el, obj, name) {
           el.text("Hello world!");
       });

There are many other options, discussed in detail in the :doc:`API
documentation <api>`.

After it's defined, it can be rendered like this::

  $(el).render(obj);

The ``render`` view method/config option (so the thing that's in the view
definition) is a handler that takes three arguments: ``el``, the element the
view is being rendered on (wrapped by jQuery), ``obj``, the object to
represent, and ``name``, the name under which this view was invoked (usually
``default``).  ``this`` is the view object itself, which may have information
and options relevant to the rendering of the view. The render method is there
to do the actual work of manipulating the DOM, hooking up event handlers, and
so on.

The render function in this view will be registered for any JavaScript
object. This is because views by default get registered for all
types of objects. Usually you want to be more specific. So, let's get
more specific and declare our view for a specific type of object, an
``iface``::

  obviel.view({
    iface: 'foo',
    render: function(el, obj, name) {
         el.text("Hello world!");
    });

Now the view will only be invoked if ``$(el).render()`` is called with
an object that has the iface ``foo``. How does an object say it
provides the iface ``foo``? You can do this by adding an ``ifaces``
attribute to the object with a list of ifaces that this object
provides::

  var something =  { 
    'ifaces': ['foo'],
    'data': 3 
  }

Or as another example::

  var a_person = {'name': 'Bob', ifaces: ['person']};

Note that the model attribute name is ``ifaces`` while the view attribute name
is ``iface``! This makes sense - a model may have more descriptions of what the
data is, but a view only knows how to render one type of data - but may be
a cause of errors that is easy to overlook.

An ``iface`` (interface) is a string marker that can be used to
describe objects, and views are connected to those ifaces. In this
way, it supports a dynamic, loose, coupling between data and views. A
view only needs to know an object has a certain iface in order to work
for it. Ifaces can also have relations to each other: a child iface
can expand a parent iface. See :ref:`lookup-and-registration` and
:ref:`interface-extension` for more information.

Of course, if a model implements an iface and a view is defined for an iface,
the view will not function correctly if the data on the model does not
actually reflect the iface (data description), and the view should assume
nothing besides the data for that iface is on the object, there is however
nothing that checks whether that is actually the case.

View composition
----------------

Often a view is composed out of other views. A larger view renders a
whole page, and sections of the page are rendered using
sub-views. These may in turn use other views for smaller fragments on
the page.

You can create sub-views by hand in a render method, like this::

  views.view({
    render: function(el, obj) {
       $('.foo', el).render(obj.attr);
    }
  });

Doing this by hand is not too bad, but the system also allows a shorter,
declarative way to express this::

  views.view({
    subviews: {
      '.foo': 'attr'
    }
  });

This does the same thing as the previous example.

The ``subviews`` attribute, if available, should define a mapping from
JQuery selector to attribute name. After the view has rendered, if any
subviews are defined, the selectors are resolved within the view's
element, and the attributes are looked up on the context object for
the view.

So, if you have this view::

   views.view({
     subviews: {
        '#alpha': 'alpha',
        '#beta': 'beta_url'
   });

And render it with the following context object::

  {alpha: {text: 'foo'},
   beta_url: '/beta.json'
  }

the system will, in effect, call::

  $('#alpha', viewelement).render({text: 'foo'})

and::

  $('#beta', viewelement).renderURL('/beta.json') 

Any callback passed to the original ('parent') render function is only
applied after all the subviews have been rendered.

You can provide a name for subviews as well by passing an array
instead of a string as the value of the subviews mapping::

  views.view({
    subviews: {
        '#selector': ['attr', 'name']
    }
  });

Here, a subview is registered for the selector '#selector', the data is looked
up on the context object using attribute name 'attr', and the view is looked
up using name 'name'.

Note that if a callback is provided to render(), it will be called after the
main view and all its subviews are done rendering.

View event registration
-----------------------

XXX this has not yet been implemented, this part serves to get the details
right before we start coding

A large part of the view's code will consist of attaching event handlers to
elements inside the view. To ease this process, and provide a pattern for
partitioning that code, the views framework allows defining events on the
view object using the 'events' attribute. This attribute should point to a
mapping from selector to event data, which in turn should be a mapping from
event name to handler. All events defined this way are registered after the
view has been rendered. An example::

  >>> views.view({
  ...     name: 'foo',
  ...     render: function(el, obj, name) {
  ...         $(el).html('<div id="foo">foo</div>bar');
  ...     },
  ...     events: {
  ...         '': {
  ...             'click': function(ev) {
  ...                 alert($(ev.target).text()); // alerts 'foobar'
  ...                 ev.preventDefault();
  ...             }
  ...         },
  ...         '#foo': {
  ...             'click': function(ev) {
  ...                 alert($(ev.target).text()); // alerts 'foo'
  ...                 ev.preventDefault();
  ...             }
  ...         }
  ...     }
  ... });

HTML mode
----------

A view can be configured so that it renders a piece of HTML. The HTML can be
pointed to using a ``html`` string or a ``html_url`` URL in the view
definition. The string is assumed to be a snippet of HTML as a string, the URL
is assumed to point to a static resource on the server and will be cached by
the system. ``render`` is called after the HTML is loaded into the element, and
can place data from the model into the rendered element, register event
handlers, etc.

XXX alternatively obey cache headers

Note that the ``html`` parameter always overrides the ``html_url`` parameter.

The HTML can also be contained in the model, this can have a ``html`` or
``html_url`` attribute too, with the same behaviour as when it would have been
provided on view definition. If the object supplies one of these attributes it
overrides the attributes supplied by the view. The general rule is that if both
configuration on the view as well as on the context object are provided, the
context object configuration takes precedence.

An example::

  views.view({
    iface: 'person',
    name: 'edit',
    html_url: 'foo.html'
  });

  var person = {'html_url': 'edit.html', ...};
  $('#someelement').render(person, 'edit')

This will result in the HTML of url 'edit.html' getting used, 'foo.html' would
only have been used if the ``person`` structure would not contain ``html_url``.

JSON Template mode
------------------

Instead of a HTML snippet, you can also supply a JSON Template
language template. This will be combined with the object to render it.
The attributes involved are ``jsont`` and ``jsont_url``, with the same
behavior as ``html`` and ``html_url``. ``jsont`` is a directly
supplied JSON Template object. The template is again a static
resource. Let's look at an example::

  views.view({
    iface: 'person',
    name: 'edit',
    jsont: '<div>{name}</div>'
  });

  $('#somediv').render({
    iface: 'person',
    name: 'John'});

This bit of code will result in '<div>John</div>' getting rendered inside any
div with id 'somediv'. JSON template views are handy, since they form a quick
way of deploying client-side templates. Note that this defines the JSON
Template in-place, but loading from URLs is of course also supported using
the ``jsont_url`` attribute, templates are automatically retrieved and
cached. Parsed versions of templates provided directly are cached as well.

It is possible to supply ``jsont_url`` or ``json`` in the model, similar to
``html_url`` and ``html``::

  views.extends('person', 'jsont');
  views.view({
    iface: 'person',
    name: 'edit'
  });
  
  person = { 'jsont_url': '/templates/person_edit.jsont', ... };
  $('#someelement').render(person, 'edit')

Form mode
---------

NOTE: this section describes the ``form`` iface, which makes that a submit
handler is attached to forms automatically, and the results are rendered, but
nothing more - the ``forms`` system that builds a framework to render widgets
based on this ``form`` iface is not touched here, it has its own documentation.
(XXX link)

A view, when rendered, may contain a form. We can automatically turn this form
into an AJAX-submitted form. If we do that, a (JSON) object is expected to be
returned when the form is submitted, which in turn is rendered using Obviel.
This behavior is triggered by setting the special ``form`` parameter. A view is
looked up on the retrieved object using ``render``, using the configuration
parameters supplied::

  views.view({
    form: {name: 'completed'},
    html_url: ...,
  });

Alternatively, ``true`` can be supplied, in which case the
configuration is assumed to be ``{name: 'default'}``. Note that the name
is only used for the view that is rendered after the form has been submitted,
the name for the form view itself is passed to render()/renderURL() in the
usual manner.

Let's consider a common case in form rendering: a self-submitting form that
keeps re-rendering itself as long as there are validation errors. The
application will only proceed if the form is correctly filled out.  How would
we implement such a protocol? We will define the object on the server to be a
JSON structure of iface ``form``, which contains an ``html`` attribute,
triggering the HTML view behavior, until it decides the submit is successful,
at which point it returns a model with a different iface (or of course an
unrelated form).

The view to initially display the form::

  views.view({
     iface: 'form',
     form: true
  });

As long as the server keeps sending a model with the iface ``form``, this view
is triggered, and the form submit handler is hooked to the html provided
on the model. If a model with a non-form iface is returned, the submit handler
is of course not hooked up.

Note: a simple view with iface ``form`` is already registered by Obviel, so
the view in the example above is not required, you can use ``form`` as an
iface without defining a view to get the described behaviour.

Iframe mode
-----------

If the ``iframe`` configuration option set to ``true``, the rendered view will
be inlined into an iframe. This iframe is constructed within the element
provided, which is assumed to allow such embedding. ``render()`` will receive
the original element as the ``el`` argument (at some point we thought it might
be smart to pass the iframe to render(), however, this does not solve much, as
render() would still need to find the body or whatnot itself, and makes it less
flexible, since render() no longer has easy access to the parent element). The
iframe will be automatically adjusted to the correct height and weight for its
contents after rendering.

The ``form`` option interacts with the ``iframe`` option: if the
``iframe`` option is set, the system will look for the form within
``$(iframe).contents()`` of the embedded iframe. 

The ``html`` attribute also interacts with the ``iframe`` option; the
contents of the html attribute will be placed within the iframe, using
``iframe.contentDocument.write()``.

Additional methods
------------------

A view may supply extra methods that it calls itself to assist in the
rendering of the view and setting up of event handlers::

  views.view({
    render: function(el, obj, name) {
      this.foo();
    },
    foo: function() {
      ...extra work...
    }
  });

Similarly additional attributes may be provided.

View inheritance
----------------

While in many cases the "additional methods" strategy as described
above is sufficient, it can also be useful to be able to define new
types of views that have their own special behavior and support their
own kinds of patterns. For this it must be understood that the
following registration::

  views.view({
    render: function(el, obj, name) { ... }
  });

is in fact a shorthand for this registration::

  views.view(new views.View({render: function(el, obj, name) { ... }}));

The system assumes that if an object that is not an instance of views.View
is supplied, this is actually the configuration for a ``View`` object. This
``View`` object in fact implements the various view modes described above.

The developer can also create new view objects by subclassing as follows::

  var MyView = function(options) {
    $.extend(true, this, options);
  };

  views.extend(MyView.prototype, views.View.prototype);
  views.extend(MyView.prototype, {
    new and overridden methods
  });


Now the new view can be registered like this::

  views.view(new MyView(...));

which may be considered cumbersome, in which case the developer can make
available a convenience function::
 
  views.myview = function(options) {
    views.view(new MyView(options));
  }

So that now you can use this to register a ``MyView``::

  views.myview(...);

In some cases you may want to create a completely different view base
class that has nothing in common with ``View`` at all. In this case it
is sufficient to implement an object that provides the ``render``
attribute, and optionally ``iface`` and ``name``, and ``isView`` set
to ``True`` to indicate that this is indeed a view and not just a
bunch of configuration options.

XXX not supported - I don't understand the purpose if something similar can
    be done with views.view() (the 'shorthand' option passing mechanism) -
    basically this mechanism will allow any object that has the expected
    attributes to be registered as a view

.. _lookup-and-registration:

Lookup and Registration
-----------------------

XXX move to/merge with top section

When registering a view, you can pass in two arguments:

* object
* name

In the future we may also want to register a view for type of element,
but we will ignore this for now - all views are registered on
all elements.

``name`` registration is simple: either a view exists with a certain
name and can be found during lookup, or it doesn't. 

Object-based (iface-based) lookup is more complicated.

Essentially, all objects in JavaScript provide a number of interfaces,
identified by id. For simple built-in objects this is simply the
type of the object (as retrieved by the ``typeof`` operator)::

  >>> views.ifaces(1)
  ["number"]
  >>> views.ifaces("foo")
  ["string"]
  >>> views.ifaces({})
  ["object"]

JavaScript objects of type ``object`` can declare that they provide
additional interfaces by adding an ``interfaces`` attribute::

  >>> views.iface('foo') // register an interface with the name 'foo'
  >>> views.ifaces({ifaces: ['foo']})
  ["foo", "base", "object"]

What happened here? We have explicitly declared that the object has
the interface with the id ``foo``. All object interfaces imply that
the object also provides a special interface with the id ``base``, so
that is also in the list. Finally, all objects provide the interface
``object``.

There are more details to interface lookup, as interfaces can extend
each other.

Events
------

XXX this is not yet implemented, this part mostly serves to discuss this new
feature before it's added

At certain moments, events are triggered by the framework so that code outside
of the views can respond to things happening on a view. Those events are:

  * views.beforerender - called just before a view is rendered on an element,
    with 'target' pointing to the element on which the view is to be rendered,
    and as additional arguments (view, obj) where 'view' is a reference
    to the view instance, and 'obj' a reference to the object being rendered.

  * views.afterrender - called just after a view has completed rendering, but
    before the callback is called (if provided), the target and arguments
    are the same as for 'BeforeRender'

  * views.cleanup - called just before a view is unrendered for an element by
    rendering a new view on that same element, target is again the element
    but arguments this time are (old_view, new_view, obj)

.. _interface-extension:

Interface Extension
-------------------

It is frequently useful to be able to register an interface more
generically, for a whole selection of related objects. We may have
more particular ``person`` objects such as ``employee``,
``contest_winner``, etc, but if we register a view for ``person``
objects we want it to automatically apply to those other types of
objects as well, unless we registered more specific views for the
latter.
 
Let's consider the following object describing a person::

  >>> bob = {name: 'Bob', location: 'US', occupation: 'skeptic'}

We can formalize what we expect from a person in this system by saying
a person must have a ``name``, ``location`` and ``occupation``
attribute (XXX ?). We skip this formalization for now, and will simply say
there is an interface in the system with the id ``person``, and that
``bob`` has the attributes necessary to provide that interface. Let's
make that explicit so that this information can be introspected::

  >>> bob = {name: 'Bob', location: 'US', occupation: 'skeptic', 
  ...        ifaces: ['person']}

  >>> views.ifaces(bob)
  ['person', 'base', 'object']

So far nothing new. But interfaces themselves can have an extension
relationship with each other: interface ``b`` can be declared to
extend interface ``a``. We've already seen an example of this, because
``person`` automatically extends the base interface ``base``.

If a view is declared for an interface with a certain id, it is also
automatically declared for all interfaces that extend that interface.

So let's imagine we have an interface ``employee`` that extends the
``person`` interface. We can tell the system about it like this::

  >>> views.extendsIface('employee', 'person')

An interface may extend an arbitrary amount of other interfaces, but
circular relationships cannot be set up. The ``views.ifaces``
function knows about extensions. So, let's say that we have an
``employee`` object::

  >>> employee = {name: 'Bob', location: 'US', occupation: 'skeptic',
  ...             wage: 0, ifaces: ['employee']}

Since we said before that any ``employee`` is also a ``person``, the
following is true::

  >>> views.ifaces(employee)
  ['employee', 'person', 'base', 'object']

Note that interfaces are sorted by topological sort, with the most
specific interfaces at the start. When looking up a view for an
object, this is useful to ensure that the views registered for the
most specific interfaces are found first.

Binding views to URLs and elements
----------------------------------

XXX just thoughts, not sure about this yet, and nothing implemented so far

It might sometimes be useful to bind a view to a URL and element, so
that it can be invoked later-on without having to provide this information.
This can be done as follows::

  >>> bound = $(selector).bindURL(url)

``bound`` is now a function that can be called later. It will look up
all elements that match the selector at that time, and will load the
object at the URL, and render it.

XXX one of the reasons I'm not sure of this yet is that we often
don't know the URL to bind to yet until we've just loaded an object
with this URL in it. We can then just as well simply use that URL,
because there's no stage to later use the bound view. So perhaps this
is not a very useful exercise.
