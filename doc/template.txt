Obviel Template
===============

Introduction
------------

Obviel Template integrates with Obviel in an important way: sub-views
can be rendered directly from the template. This allows these views to
respond to events in the standard Obviel way, including responding to
object events. Obviel Template can do this because it's DOM-based, not
text-based. Doing this with a text-based template language (such as
JSON Template) isn't possible, as it isn't aware of DOM elements at
all.

Another powerful feature of Obviel Template is that it supports i18n
markers directly in the template for the purpose of
internationalization (i18n) of template texts. This way automatic
extraction tools can be used to maintain translations of strings in
the template. This feature is inspired by some server-side template
languages (such as Zope Page Templates), but this is not commonly
supported by client-side template languages.

Obviel Template is deliberately a very minimal template
language. Logic should be kept in code, not templates. If you need
logic, preprocess the object that goes into the template instead.

Variables
---------

Obviel-Template supports variable interpolation using ``{}`` markers
in text. It looks like this::

  <p>{content}</p>

If you combine that template with a JavaScript object with the
following structure::

  {
    content: "Hello world!"
  }

it will result in a rendered template like this::

  <p>Hello world!</p>

What if the ``content`` property is not available in the JavaScript
object, and is thus ``undefined``? Obviel Template considers this an
error and the template will fail with a ``RenderError`` exception.

Dotted names in variables
-------------------------

Objects can be nested::

  {
    a: {
      b: "The value"
    }
  }

You can indicate such nested values in a variable using a dotted
name::

  <p>{a.b}</p>

Rendering the template with the object will result in this::

  <p>The value</p>

If you refer to a dotted name that does not exist in the data, this is
an error and the template won't render; you get a ``RenderError``
exception.

Dotted names also work in directives like ``data-with``, ``data-if``
and ``data-each``, which we'll see next.

``data-with`` for scope control
-------------------------------

You can change the object in which variables are found with the
``data-with`` directive. Given the same nested structure as before::

  {
    a: {
      b: "The value"
    }
  }

you can express the template like::

  <div>
    <p data-with="a">{b}</p>
  </div>

Rendering the template with the object will result in this::

  <div>
    <p>The value</p>
  </div>

``data-with="a"`` indicates that within the ``p`` element, lookups
will be performed in the ``b`` object primarily (that is the *scope*
of that element).


``data-with`` must point to an object; it cannot point to strings or
arrays or other values, and cannot point to a missing value either:
these are ``RenderError`` errors.

``data-if`` for conditionals
----------------------------

Sometimes you want to include an element only if a given value is true
or not. For the purposes of ``data-if``, a value is *false* if:

* it is the ``false``

* it is ``null``

* it is ``undefined``

* it is ``0``

* it is an empty string ``""``

* it is an empty array

* the value is missing entirely

Otherwise, the value is considered *true*.

With ``!``, the behavior of ``data-if`` can be reversed: values that 
evaluate to false *will* be included.

Consider this template::

  <p data-if="person">Hello {person.name}!</p>
  <p data-if="!person">{person.name} is not present</p>

Here's a data structure with ``person`` present::

  {
    person: {
      name: "Evan"
    }
  }

rendering the template will result in this::

  <p>Hello Evan!</p>

but if you have a data structure without ``person`` present, such as this::

  { 

  }

the template will render like this::

  <p>Evan is not present</p>

``data-each`` for repetition
----------------------------

If you point to an array with ``data-each``, it will render each entry
in the array into the DOM. So with a data structure like this::

  {
    persons: [
       {
         name: "Bob"
       },
       {
         name: "Steven"
       }
    ]
  }

and a template like this::
 
  <ul>
    <li data-each="persons">{name}</li>
  </ul>

the result will be this::

  <ul>
    <li>Bob</li>
    <li>Steven</li>
  </ul>
 
Note that ``data-each`` changes the scope (like
``data-with``). ``data-each`` changes the object in which the
variables are looked up to each entry in the array, one by one.

If the array is empty, nothing will be rendered at all. So, this
data::

  {
    persons: [
    ]
  }

will result in this::

  <ul>
  </ul>

You can use the special variable ``@.`` to render simple arrays where
each item is not an object in itself. For instance::

  {
    persons: [
      "Bob", "Steven", "Jay"
    ]
  }

and this template::

  <ul>
    <li data-each="persons">{@.}</li>
  </ul>

will render like this::

  <ul>
    <li>Bob</li>
    <li>Steven</li>
    <li>Jay</li>
  </ul>

Interpolating the current object: ``@.``
----------------------------------------

Sometimes you want to interpolate the current object or array into the
document (as JSON), mostly for debugging purposes. For this you can
use ``{@.}`` as well.

Consider this data::

  {
    title: "Foo"
  }

and this template::

  <div>
    {@.}
  </div>

Rendering the template with the data will result in this::

  <div>
    {
      title: "Foo"
    }
  </div>

Nested scoping
--------------

Values in outer scopes are available for variables in inner
scopes. Consider this structure of objects::

  {
   a: {
     b: "The value"
   },
   c: "Outer value"
   d: {
     e: "Value in outer object"
   }
  }

In the scope ``a``, we can still access ``c`` and ``d`` (and even
``a`` again)::

 <p>b in outer scope: {a.b}</p>
 <p>c in outer scope: {c}</p>
 <p>e in outer scope: {e}</p>
 <p data-with="a">b in scope a: {b}</p>
 <p data-with="a">c in scope a: {c}</p>
 <p data-with="a">e in scope a: {d.e}</p>
 <p data-with="a">b in a in scope a: {a.a.b}</p>

But if you redefine a name in an inner scope, you cannot access the
value in the outer scope::

  {
    a: {
      b: 'redefined'
    }
    b: 'original'
  }

  <p data-with="a">b in scope a: {b}</p>

will therefore get you::

  <p>b in scope a: redefined</p>

``data-view``
-------------

Consider the following data::

  {
    greeting: "Hello",
    who: {
      iface: 'person',
      name: "Pat Pending",
      url: "http://www.example.com/pat_pending"
    }
  }

and this template::

  <p>{greeting} <span><a data-with="who" href="{url}">{name}</a></span></p>

it will render like this::

  <p>Hello <span><a href="http://www.example.com/pat_pending">Pat Pending</a></span></p>

This works. But we could also arrange our code so that we have a view
for the ``person`` iface and use that instead. The advantage of that
is that we could reuse this view in other places, and in addition we
can use an Obviel view to hook up to events and so on. Let's consider
a view::

  obviel.view({
     iface: 'person',
     obvt: '<a href="{url}">{name}</a>'
  });

This is a view for the iface ``person``. We use the Obviel Template
(indicated by ``obvt``) to render the view.

Now we can change our template to render ``who`` as a view::

  <p>{greeting} <span data-view="who"></span></p>

The result is still the same::

  <p>Hello <span><a href="http://www.example.com/pat_pending">Pat Pending</a></span></p>

By using ``data-view``, you have made the outer template more generic.
If the object indicated by the name ``who`` has another ``iface``, the
template will still work unchanged. For example, here is a data
structure where ``who`` is a robot::

  {
    greeting: "Greetings",
    who: {
      iface: 'robot',
      designation: "OVL-R 4711",
    }
  }
 
and this is a view for the iface ``robot``::

  obviel.view({
     iface: 'robot',
     obvt: '{designation}'
  });

and here is our template again::

  <p>{greeting} <span data-view="who"></span></p>

when we render the data now, we get this::

  <p>Greetings <span>OVL-R 4711</span></p>

in other words, if you add ``data-view`` to an element ``el`` to
render object ``who``, Obviel Template will do the equivalent of this::

  $(el).render(who);

Sometimes you have multiple views for an ``iface``, distinguished by
name. You can indicate the name used by ``data-view`` with a ``|``
character. Here's another view for ``person`` with the name ``extended``::

  obviel.view({
     iface: 'person',
     name: 'extended',
     obvt: 'The person has the name <a href="{url}">{name}</a>'
  });


and here is how you refer to this ``extended`` view::

  <p>{greeting} <span data-view="who|extended"></span></p>

``data-view`` must point to an object. It cannot point to an array or
other value.

Including HTML
--------------

Interpolation escapes HTML, so if you try to insert the following::

  {
    my_html: "<p>Hello</p>"
  }

with this template::

  <div>{my_html}</div>

the HTML will be included but escaped::

  <div>&lt;p&gt;Hello&lt;/p&gt;</div>

Usually this is what you want, especially when you are dealing with
user input, for security purposes.

But what if you want to insert some HTML? You can do this using a 
Normally interpolation escapes HTML. You can however also include HTML
in data as HTML.  Consider this data::

  {
    my_html: "<p>Hello</p>"
  }

with this template::

  <div>{my_html}</div>

the HTML will be included but escaped. Usually this is what you want,
especially when dealing with user input::

  <div>&lt;p&gt;Hello&lt;/p&gt;</div>

but sometimes you want to include the HTML literally. You can do this by
indicating this in the interpolation with ``|html``::

  <div>{my_html|html}></div>

now if you render the same data, you will get this::

  <div><p>Hello</p></div>


data-i18n
---------

Obviel Template offers the ability to write a template that can be
shown in other languages as well. If we have a template like this::

 <p data-i18n="">Hello world!</p>

we can also show this template in the Dutch language given the appropriate
translation data::

 <p>Hallo wereld!</p>

``data-i18n`` is used to mark up those parts of the template that
should be translatable, such as attributes and texts. These
translatable values can contain variables as well:

  <p data-i18n="">Hello {who}!</p>

XXX stuff about po files and spelling

XXX what happens if HTML is in the section marked?

By default, ``data-i18n`` is used to mark the textual content of a tag
for translation. You can indicate that you want to translate an attribute
like this::

  <blah data-i18n="title" title="Hello" />

You can indicate multiple attributes by space separated names::

  <blah data-i18n="title other" title="Hello" other="Something" />

You can indicate attributes *and* element contents with the special
name ``.``:

  <blah data-i18n=". title" title="Hello">Contents</blah>

Order
-----

You can combine the attributes ``data-if``, ``data-each``,
``data-with``, and ``data-view`` on an element::

  <p data-if="a" data-each="b" data-with="c" data-view="d"></p>

This means that if the value ``a`` is present and true, the ``p``
element will be included in the rendered template. After this,
for each of the entries in ``b``, we render the object ``d`` in the
``c`` scope with a view.

``data-i18n`` will also apply after ``data-if``. ``data-with`` and
``data-i18n`` do not interact directly, but of course ``data-with`` is
already applied when any variable interpolation that can affect
``data-i18n`` happens, so ``data-i18n`` can also be seen as applying
after ``data-with``.

``data-i18n`` can only be combined with ``data-view`` if ``data-i18n``
refers to attributes only, not element content; any other combination is
an error.

id support
----------

Obviel templates should be valid HTML fragments. In valid HTML, a id
should be unique. Ids are allowed::
 
  <div id="foo"></div>

But variables in ids are not allowed, so this is **illegal**::

  <div id="{not_allowed}"></div>

To generate an id, you can instead use the ``data-id`` command::

  <div data-id="{some_id}"></div>

This works just like any other attribute, so you can put things before
and after the variable::

  <div data-if="prefix{some_id}postfix"></div>

support for gettext message ids
-------------------------------

XXX If a message id enters the template, it's automatically translated.

Formatters
----------

...

Literals
--------

Injecting the characters ``{`` and ``}`` can be done using a special
markup::

  {!open} 

  {!close}

Unsupported XML constructs
--------------------------

The HTML CDATA section implementation in browsers is so inconsistent we
didn't think it was worth spending time supporting this in templates, given
its limited utility. Obviel Template therefore has undefined behavior in
the presence of one in your template: we recommend you don't use any.

Similarly, process instructions are not supported.
